<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<title>Sproingies in WebGL</title>
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" />
<style type="text/css">
body {
    font-family: Sans-Serif;
    font-size: 0.7em;
    background: #000;
}
#glCanvas {
    display: block;
    border: none;
    width: 100%;
    height: 100%;
}
#infoDialog {
    font-size: 0.9em;
    line-height: 1.5em;
}
.infoIcon {
    display: block;
    float: left;
    border: 0;
    padding: 0;
    margin: 0 16px 5px 0;
}
.version {
    color: #888;
    padding-top: 0.4em;
}
.version2, .showFPS {
    display: block;
    font-size: 0.9em;
    position: absolute;
    bottom: 2em;
    left: 1.2em;
    color: #888;
}
.redBox {
    background-color: #FFAAAA;
    padding: 0.5em 1em;
}
#loadingWebGL {
    padding-top: 40%;
    color: #eee;
    text-align: center;
    font-size: 1.2em;
}
#missingWebGL {
    display: none;
    width: 600px;
    font-size: 1.1em;
    background-color: #EDEDED;
    padding: 0.5em 1em;
    margin: 5px auto;
    text-align: center;
    line-height: 1.5em;
}
#missingWebGL a {
    display: block;
    margin-top: 1em;
    font-weight: bold;
}
#toolbar {
    display: block;
    position: fixed;
    left: 0;
    bottom: 20px;
    margin: 0 auto;
    text-align: center;
    width: 100%;
}
#toolbar .ui-button {
    margin-right: 0.4em;
}
.sliderBox {
    display: block;
    float: left;
    text-align: center;
    border: 1px solid #A6C9E2;
    margin: 5px;
    padding: 2px 10px;
    width: 5em;
}
.sliderBox p {
    clear: both;
    margin: 5px 0;
    line-height: 1.4em;
}
#settingsSliders span {
	height: 140px;
	display: block;
	margin: 0 auto;
}
#glCanvas {
    /* display will be set to "block" after javascript confirms WebGL availability. */
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -10;
}
</style>

<!--
 ** Please read the credits & software licenses:
 ** https://bitbucket.org/emackey/sproingies/wiki/Licenses
 -->
<link rel="stylesheet" href="css/start/jquery-ui-1.8.13.custom.css" />
<script type="text/javascript" src="js/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="js/webgl-utils.js"></script>
<script type="text/javascript" src="js/jquery-1.5.1.min.js"></script>
<script type="text/javascript" src="js/jquery-ui-1.8.13.custom.min.js"></script>
<script type="text/javascript" src="js/S1_b.js"></script>

<!--
 ** Sproingie fragment & vertex shaders
 -->
<script id="shader-fs-sproingie" type="x-shader/x-fragment">
  #ifdef GL_ES
  precision highp float;
  #endif
  
  //
  // This is the fragment shader for the Sproingies.
  //
  uniform vec4 uKeyLightColor;
  uniform vec3 uKeyLightPos;  // Light positions should be premultiplied with thier own view matrix.
  uniform vec4 uFillLightColor;
  uniform vec3 uFillLightPos;
  uniform vec4 uMaterialColor;
  uniform vec4 uMaterialSpecular;
  uniform vec4 uMaterialAltColor;

  varying vec3 vNormal;
  varying vec4 vViewPos;
  varying vec2 vUVCoords;

  void pointLight(in vec3 N, in vec3 V, in float shininess,
                  inout vec4 diffuse, inout vec4 specular,
                  in vec4 lightColor, in vec3 lightPos)
  {
    vec3 D = lightPos - V;
    vec3 L = normalize(D);

    float nDotL = dot(N,L);

    if (nDotL > 0.0)
    {   
        vec3 halfVector = normalize(L + vec3(0.0, 0.0, 1.0));
        float pf = pow(max(0.0, dot(N, halfVector)), shininess);

        diffuse  += lightColor * nDotL;
        specular += lightColor * pf;
    }
  }
  
  float modf(float x, float y) {
    return x - (y * floor(x/y));
  }
  
  void main(void) {
    vec3 n = normalize(vNormal);
   
    vec4 diffuse  = vec4(0.0);
    vec4 specular = vec4(0.0);

 // pointLight(n, vViewPos.xyz, 50.0, diffuse, specular, uKeyLightColor, uKeyLightPos);
    pointLight(n, vViewPos.xyz, 1000.0, diffuse, specular, uKeyLightColor, uKeyLightPos);
 // pointLight(n, vViewPos.xyz, 0.0, diffuse, specular, uKeyLightColor, uKeyLightPos);
   
    pointLight(n, vViewPos.xyz, 50.0, diffuse, specular, uFillLightColor, uFillLightPos);

    vec4 surfaceColor = uMaterialColor;
    if (modf(floor(vUVCoords.y), 2.0) > 0.5) {
        surfaceColor = uMaterialAltColor;
    }

    vec4 color = (diffuse  * surfaceColor) +
                 (specular * uMaterialSpecular);
                
    color = clamp(vec4(color.rgb, 1.0), 0.0, 1.0);
   
    gl_FragColor = color;
  }
</script>

<script id="shader-vs-sproingie" type="x-shader/x-vertex">
  //
  // This is the vertex shader for the Sproingies.
  //
  attribute vec3 aVertexPosition;
  attribute vec3 aVertexNormal;
  attribute vec2 aUVCoords;

  uniform mat4 uMVMatrix;
  uniform mat4 uProjMatrix;
  uniform mat3 uNormalMatrix;

  varying vec3 vNormal;
  varying vec4 vViewPos;
  varying vec2 vUVCoords;

  void main(void) {
    vNormal = normalize(uNormalMatrix * aVertexNormal);
    vViewPos = uMVMatrix * vec4(aVertexPosition, 1.0);
    vUVCoords = aUVCoords;
    gl_Position = uProjMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
</script>


<!--
 ** Sproingie explosion fragment & vertex shaders
 -->
<script id="shader-fs-boom" type="x-shader/x-fragment">
  #ifdef GL_ES
  precision highp float;
  #endif
  
  //
  // This is the fragment shader for exploding Sproingies.
  //
  uniform vec4 uColor;
  uniform sampler2D uDotSampler;

  void main(void) {
    float alpha = texture2D(uDotSampler, gl_PointCoord).r;
    gl_FragColor = vec4(uColor.rgb, alpha);
    if (alpha < 0.0001) {
      discard;
    }
  }
</script>

<script id="shader-vs-boom" type="x-shader/x-vertex">
  //
  // This is the vertex shader for exploding Sproingies.
  //
  attribute vec3 aVertexPosition;

  uniform mat4 uMVMatrix;
  uniform mat4 uProjMatrix;
  uniform float uPointSize;

  void main(void) {
    gl_PointSize = uPointSize;
    gl_Position = uProjMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
</script>


<!--
 ** Ground fragment & vertex shaders
 -->
<script id="shader-fs-ground" type="x-shader/x-fragment">
  #ifdef GL_ES
  precision highp float;
  #endif
  
  //
  // This is the fragment shader for the ground (staircase) under the Sproingies.
  //
  varying vec4 vColor;
  varying vec3 vGroundPos;

  void main(void) {
    // This extra bit of per-pixel logic fades the top & bottom of the staircase to black.
    float dist = clamp((2.0 - abs(vGroundPos.y / 45.0)), 0.0, 1.0);
    
    // You can swap the commented line for the one below to
    // see the fadeout zone in red, for debugging/adjusting.
    //gl_FragColor = vec4(1.0-dist, (vColor.gb * dist), 1.0);  // Red fadeout zone
    gl_FragColor = vec4((vColor.rgb * dist), 1.0);
  }
</script>

<script id="shader-vs-ground" type="x-shader/x-vertex">
  //
  // This is the vertex shader for the ground (staircase) under the Sproingies.
  //
  attribute vec3 aVertexPosition;
  attribute vec3 aVertexNormal;

  uniform mat4 uMVMatrix;
  uniform mat4 uProjMatrix;
  uniform mat3 uNormalMatrix;
  uniform vec4 uCameraMatrix;

  uniform vec4 uKeyLightColor;
  uniform vec3 uKeyLightPos;  // Light positions should be premultiplied with thier own view matrix.
  uniform vec4 uFillLightColor;
  uniform vec3 uFillLightPos;
  uniform vec4 uMaterialColor;
  uniform vec4 uMaterialSpecular;
  uniform vec4 uMaterialAltColor;
  uniform vec3 uGroundPos;

  varying vec4 vColor;
  varying vec3 vGroundPos;
  
  // This is a rare case where per-vertex lighting looks nicer than per-pixel.
  // With per-vertex, a group of ground cube side walls all have different
  // shades, and offer some contrast from each other.  But with per-pixel lit
  // ground cubes, all the side walls blend seamlessly and the edges disappear.
  // So we light the ground per-vertex, and we light the Sproingies per-pixel.

  void pointLight(in vec3 N, in vec3 V, in float shininess,
                  inout vec4 diffuse, inout vec4 specular,
                  in vec4 lightColor, in vec3 lightPos)
  {
    vec3 D = lightPos - V;
    vec3 L = normalize(D);

    float nDotL = dot(N,L);

    if (nDotL > 0.0)
    {
        vec3 halfVector = normalize(L + vec3(0.0, 0.0, 1.0));
        float pf = pow(max(0.0, dot(N, halfVector)), shininess);

        diffuse  += lightColor * nDotL;
        specular += lightColor * pf;
    }
  }
  
  void main(void) {
    vec3 vNormal = normalize(uNormalMatrix * aVertexNormal);
    vec4 vViewPos = uMVMatrix * vec4(aVertexPosition, 1.0);
    vGroundPos = aVertexPosition + uGroundPos;
    gl_Position = uProjMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    
    vec3 n = normalize(vNormal);
    vec4 diffuse  = vec4(0.0);
    vec4 specular = vec4(0.0);

    vec3 viewPos3 = (vec3 (vViewPos)) / vViewPos.w;
    pointLight(n, viewPos3, 50.0, diffuse, specular, uKeyLightColor, uKeyLightPos);
    pointLight(n, viewPos3, 50.0, diffuse, specular, uFillLightColor, uFillLightPos);
    
    vec4 color = (diffuse  * uMaterialColor) +
                 (specular * uMaterialSpecular);

    // Make the tops of the ground a lighter color.
    if (aVertexNormal.y > 0.5) {
        // Arbitrary gamma tweaking, because it looks like the original when I do this.
        diffuse = 1.0 - ((1.0 - diffuse) * 0.8);
        specular = 1.0 - ((1.0 - specular) * 0.8);
    
        color = // tops
          (diffuse  * vec4(0.392157, 0.784314, 0.941176, 1.0)) +
          (specular * vec4(0.2, 0.2, 0.2, 1.0));
    }
                
    vColor = clamp(vec4(color.rgb, 1.0), 0.0, 1.0);
  }
</script>


<script type="text/javascript">
var DIRECTION_UP=-1;
var DIRECTION_DOWN=1;
var TYPE_SLINKY =	0;
var TYPE_JUMP =		1;
var TYPE_ROLL =		2;
var NUM_TYPES =		3;

var DEFAULT_NUM_SPROINGIES = 35;
var DEFAULT_SPEED          = 18;
var DEFAULT_GROUND         =  2;
var DEFAULT_WEIRDNESS      =  4;
var DEFAULT_TYPE           =  TYPE_SLINKY;

var CAMERA_SLIDE_RATE = 0.998;
var BOOM_STAGE = 50.0;
var S_RES = 28;
var M_TWOPI = Math.PI * 2.0;
var DegToRad = Math.PI / 180.0;

// Bits for m_weirdBits field in Sproingies.
var SP_BIT_AIRDROP         = 1;
var SP_BIT_STRIPES         = 2;
var SP_BIT_FAT             = 4;

var sproingieList = [];
var mouseDown = -1;
var lastMouseX = 0;
var lastMouseY = 0;
var target_wait = 0.0001, max_target_wait = 100.0;
var ground = 0.0, rotx = 0.0, roty = -45.0, dist = 32.0;
var target_rx = 0.0, target_ry = -45.0, target_dist = 32.0;
var lookAway = 1.5;
var looking = -0.5;
var howfast = DEFAULT_SPEED;
var groundlevel = DEFAULT_GROUND;
var weirdness = DEFAULT_WEIRDNESS;

var gl;  // the WebGL context
var glCanvasName = "glCanvas";

var MAX_TOOLBAR_LIFE = 5;
var TOOLBAR_FADE_SPEED = 500;
var toolbarLife = MAX_TOOLBAR_LIFE;
var toolbarVisible = true;
var fpsFrames = 0, fpsTime = 0;
var lastTime = 0;
var isPaused = false;

var groundBuffers;
var sproingieBuffers;
var sproingieBoomBuffers;
var groundShaderProgram;
var sproingieShaderProgram;
var sproingieBoomShaderProgram;
var dotTexture;

var colorTime=0;
var groundRGB = [ 0.156863, 0.156863, 0.392157 ];
var nextGroundRGB = [ 0.156863, 0.156863, 0.392157 ];


var worldWidth=8;
var worldHeight=5;

var BOXINESS = 0;

var SPECULAR = 0.5;

var keyPos = [0.0, 0.0, -16.0];
var lightRot = 0;
var lightRotSpeed = 0.05;

var rotCameraX = [0.0, 0.0, 0.0, 0.0];
var rotCameraY = [0.0, 0.0, 0.0, 0.0];
var rotCameraZ = 0.0;

var eye = [0.0, 0.0, 16.0];
var lookAt = [0.0, 1.0, 0.0];
var up = [0.0, 1.0, 0.0];
var cameraMatrix = [eye, lookAt, up];
var zoomLevel = 100;
var zoom = [0.80, 0.15, 0.9, 0.5];
var selectedCam = 0; 
var camera1 = [0.0, 0.0, -16.0]; 
var camera2 = [1.0, 10.0, -3.0];
var camera3 = [20.0, 0.0, -64.0];
var camera4 = [-0.0, 4.0, 16.0];
var cameras = [camera1, camera2, camera3, camera4];

//                  Misc helpful URLs
//  Sproingie Wiki: https://bitbucket.org/emackey/sproingies/wiki/
//          JSLint: http://www.jslint.com/
//      WebGL Spec: http://www.khronos.org/registry/webgl/specs/latest/
//       GLSL Spec: http://www.opengl.org/sdk/docs/manglsl/
//    glMatrix lib: http://code.google.com/p/glmatrix/
// WebGL Inspector: http://benvanik.github.com/WebGL-Inspector/

//
// Initialize WebGL
//
function initGL(canvas) {
    try {
        gl = WebGLUtils.setupWebGL(canvas);
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
    }
    catch (ex) { }

    if (gl) {
        document.getElementById("loadingWebGL").style.display = "none";
        document.getElementById("glCanvas").style.display = "block";
        resizeGL();
    }
    else {
        document.getElementById("loadingWebGL").style.display = "none";
        document.getElementById("missingWebGL").style.display = "block";
        $("#play,#showInspector,#showSettings").button("option", "disabled", true);
    }
}

function resizeGL() {
    var canvas = document.getElementById(glCanvasName);
    gl.viewportWidth = canvas.width = canvas.clientWidth;
    gl.viewportHeight = canvas.height = canvas.clientHeight;
    //document.getElementById("info").innerHTML = "Size " + gl.viewportWidth + " x " + gl.viewportHeight;
}

//
// Fetch a shader from another script block, and compile it.
//
function getShader(gl, id) {
    var shaderScript = document.getElementById(id);
    if (!shaderScript) {
        return null;
    }

    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
        if (k.nodeType === 3) {
            str += k.textContent;
        }
        k = k.nextSibling;
    }

    var shader;
    if (shaderScript.type === "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type === "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
        return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(id + " compile error:\n\n" + gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
}

//
// Init a shader program.
//
function initShaders(shaderProgram, fsName, vsName) {
    var fragmentShader = getShader(gl, fsName);
    var vertexShader = getShader(gl, vsName);

    if ((fragmentShader !== null) && (vertexShader !== null)) {
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
    }

    gl.useProgram(shaderProgram);

    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

    shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
    gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

    //  attribute vec2 aUVCoords;
    shaderProgram.aUVCoords = gl.getAttribLocation(shaderProgram, "aUVCoords");
    if (shaderProgram.aUVCoords) {
        gl.enableVertexAttribArray(shaderProgram.aUVCoords);
    }

    // Vertex shader uniforms
    //  uniform mat4 uMVMatrix;
    //  uniform mat4 uProjMatrix;
    //  uniform mat4 uNormalMatrix;
    //  uniform vec3 uGroundPos;
    shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uProjMatrix");
    shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    shaderProgram.normalMatrixUniform = gl.getUniformLocation(shaderProgram, "uNormalMatrix");
    shaderProgram.groundPosUniform = gl.getUniformLocation(shaderProgram, "uGroundPos");

    // Fragment shader uniforms
    //  uniform vec4 uKeyLightColor;
    //  uniform vec3 uKeyLightPos;  // Light positions should be premultiplied with thier own view matrix.
    //  uniform vec4 uFillLightColor;
    //  uniform vec3 uFillLightPos;
    //  uniform vec4 uMaterialColor;
    //  uniform vec4 uMaterialSpecular;
    //  uniform vec4 uMaterialAltColor;
    shaderProgram.uKeyLightColor = gl.getUniformLocation(shaderProgram, "uKeyLightColor");
    shaderProgram.uKeyLightPos = gl.getUniformLocation(shaderProgram, "uKeyLightPos");
    shaderProgram.uFillLightColor = gl.getUniformLocation(shaderProgram, "uFillLightColor");
    shaderProgram.uFillLightPos = gl.getUniformLocation(shaderProgram, "uFillLightPos");
    shaderProgram.uMaterialColor = gl.getUniformLocation(shaderProgram, "uMaterialColor");
    shaderProgram.uMaterialSpecular = gl.getUniformLocation(shaderProgram, "uMaterialSpecular");
    shaderProgram.uMaterialAltColor = gl.getUniformLocation(shaderProgram, "uMaterialAltColor");
}

function initBoomShaders(shaderProgram, fsName, vsName) {
    var fragmentShader = getShader(gl, fsName);
    var vertexShader = getShader(gl, vsName);

    if ((fragmentShader !== null) && (vertexShader !== null)) {
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
    }

    gl.useProgram(shaderProgram);

    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

    // Vertex shader uniforms
    //  uniform mat4 uMVMatrix;
    //  uniform mat4 uProjMatrix;
    //  uniform float uPointSize;
    shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uProjMatrix");
    shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    shaderProgram.uPointSize = gl.getUniformLocation(shaderProgram, "uPointSize");
    shaderProgram.groundPosUniform = null;

    // Fragment shader uniforms
    //  uniform vec4 uColor;
    //  uniform sampler2D uDotSampler;
    shaderProgram.uColor = gl.getUniformLocation(shaderProgram, "uColor");
    shaderProgram.uDotSampler = gl.getUniformLocation(shaderProgram, "uDotSampler");
}

//
// Textures
//
function handleLoadedTexture(texture) {
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
    gl.generateMipmap(gl.TEXTURE_2D);

    gl.bindTexture(gl.TEXTURE_2D, null);
}

function initTextures() {
    dotTexture = gl.createTexture();
    dotTexture.image = new Image();
    dotTexture.image.onload = function() {
        handleLoadedTexture(dotTexture);
    };
    dotTexture.image.src = "images/dot.png";
}

//
// Set various uniforms
//
function setProjectionUniforms(shaderProgram, pMatrix, groundPos) {
    gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
    if (shaderProgram.groundPosUniform !== null) {
        gl.uniform3f(shaderProgram.groundPosUniform, groundPos[0], groundPos[1], groundPos[2]);
    }
}

function setMatrixUniforms(shaderProgram, mvMatrix) {
    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);

    // modelview inverse = transpose(inverse(mv))
    var normalMatrix = mat3.create();
    mat4.toInverseMat3(mvMatrix, normalMatrix);
    mat3.transpose(normalMatrix);
    gl.uniformMatrix3fv(shaderProgram.normalMatrixUniform, false, normalMatrix);
}

function setLights(shaderProgram, lightMatrix) {

    mat4.multiplyVec3(lightMatrix, keyPos);
 
    //mat4.rotate(lightMatrix, lightRot, [1, 0, 0]);
    gl.uniform4f(shaderProgram.uKeyLightColor, (254 / 255.0), (239 / 255.0), (203 / 255.0), 1.0);
    gl.uniform3f(shaderProgram.uKeyLightPos, keyPos[0], keyPos[1], keyPos[2]);

    var fillPos = [4.0, 0.0, 24.0];
    mat4.multiplyVec3(lightMatrix, fillPos);
    gl.uniform4f(shaderProgram.uFillLightColor, (0.4 * 213 / 255.0), (0.4 * 205 / 255.0), (0.4 * 235 / 255.0), 1.0);
    gl.uniform3f(shaderProgram.uFillLightPos, fillPos[0], fillPos[1], fillPos[2]);
}

function setMaterial(shaderProgram, r, g, b, specular, altR, altG, altB) {
    gl.uniform4f(shaderProgram.uMaterialColor, r, g, b, 1.0);
    gl.uniform4f(shaderProgram.uMaterialSpecular, specular, specular, specular, 1.0);
    gl.uniform4f(shaderProgram.uMaterialAltColor, altR, altG, altB, 1.0);
}

function setBoomUniforms(shaderProgram, mvMatrix, r, g, b, pointSize) {
    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    gl.uniform4f(shaderProgram.uColor, r, g, b, 1.0);
    gl.uniform1f(shaderProgram.uPointSize, pointSize);
}

//
// Misc helper functions
//
function myrand(range) {
    return Math.floor(Math.random() * range);
}

function XtoY(x, y) {
	var z = Math.abs(x);
	if (z < 1e-20) {
		return 0.0;
	}

	var a = Math.exp(y * Math.log(z));

	if (x < 0) {
		a = -a;
	}
	return a;
}

function MakeNormal(v1, v2, normals) {
	normals.push((v2[1] * v1[2]) - (v1[1] * v2[2]),
				 (v2[2] * v1[0]) - (v1[2] * v2[0]),
				 (v2[0] * v1[1]) - (v1[0] * v2[1]));
}

//
// Sproingie object declaration
//
function Sproingie(index, max) {
	this.m_X = 0;
	this.m_Y = 0;
	this.m_Z = 0;
	this.m_weirdBits = 0;
	this.m_life = ((-index * ((max > 19) ? 1.0 : 4.0)) - 2.0);
	this.m_stage = 0.0;
	this.m_speed = 0.0;
	this.m_boxiness = 0.02;
	this.m_width = 1.0;
	this.m_R = (40 + myrand(200)) / 255.0;
	this.m_G = (40 + myrand(200)) / 255.0;
	this.m_B = (40 + myrand(200)) / 255.0;
	this.m_index = index;	
	this.m_jumping = false;
	this.m_flipJump = false;
	this.m_jumpUp = false;
	
	if ( this.m_index == 0)
		this.m_type = TYPE_JUMP; //Main Sproingie always is a jumper
	else
		this.m_type = myrand(NUM_TYPES);
}

Sproingie.prototype.ResetSproingie = function() {
    this.m_life = (-30 + myrand(28));
};

Sproingie.prototype.CheckCollision = function(maxStage) {    
	var len = sproingieList.length;
    var t2;
	
	if (this.m_index == 0) //Don't do collision detection for our main sproingie
		return false;
		
    for (t2 = 1; t2 < len; ++t2) {
        if ((t2 !== this.m_index) && (this.m_X === sproingieList[t2].m_X) &&
            (this.m_Y === sproingieList[t2].m_Y) && (this.m_Z === sproingieList[t2].m_Z) &&
            (sproingieList[t2].m_life > 10.0) && (sproingieList[t2].m_stage < maxStage)) {
			
			if (!sproingieList[t2].m_merge && !this.m_merge)
			{
				sproingieList[t2].m_weirdBits = 2;
				sproingieList[t2].m_altR = this.m_R;
				sproingieList[t2].m_altG = this.m_G;
				sproingieList[t2].m_altB = this.m_B;
				sproingieList[t2].m_merge = true;
				sproingieList[t2].m_width=1.75;
				this.m_life=0;
				return false;
			}
			
            return true;
        }
    }
    return false;
};

Sproingie.prototype.AdvanceSproingie = function(nextStage) {
    var g_higher, g_back;
    var index = this.m_index;
    var useDifferentSpeeds = ((weirdness > 1) && (index > 1));

    if (this.m_life > 0.0) {
        if (this.m_stage < BOOM_STAGE) {
            nextStage *= this.m_speed;
        }
				
		var locX = -this.m_X-this.m_Y/2;
		//var locY = -this.m_Y;
			//Right Side			Left Side
		if ( ((locX < -worldWidth) || (locX > worldWidth) || (Math.abs(this.m_Y/2) >= worldHeight)) &&	this.m_life > 10.0)	
			{
				this.m_life = 10;
				this.m_stage= BOOM_STAGE;
				if ((this.m_R += 0.5) > 1.0) { this.m_R = 1.0; }
                if ((this.m_G += 0.5) > 1.0) { this.m_G = 1.0; }
                if ((this.m_B += 0.5) > 1.0) { this.m_B = 1.0; }
			}

        if ((this.m_stage += nextStage) >= 12.0) {
            if (this.m_stage >= BOOM_STAGE) {
                if ((this.m_R -= nextStage * 0.08) < 0.0) { this.m_R = 0.0; }
                if ((this.m_G -= nextStage * 0.08) < 0.0) { this.m_G = 0.0; }
                if ((this.m_B -= nextStage * 0.08) < 0.0) { this.m_B = 0.0; }

                if ((this.m_life -= nextStage) <= 0.0000001) {
                    this.ResetSproingie();
                }
                return;
            }
			
			
				this.m_X += 1;
				this.m_Y -= 2;
				this.m_Z += 1;
				this.m_stage -= 12.0;
			

            if ((this.m_life > 10.0) && this.CheckCollision(6.0)) {
                this.m_life = 10.0;
                this.m_stage = BOOM_STAGE;
                if ((this.m_R += 0.5) > 1.0) { this.m_R = 1.0; }
                if ((this.m_G += 0.5) > 1.0) { this.m_G = 1.0; }
                if ((this.m_B += 0.5) > 1.0) { this.m_B = 1.0; }
            }
			
			
        }

				
        if (this.m_life < 9.0) {
            if (this.m_stage < 1.0) {
                this.m_stage -= nextStage * 2.0;
                if (this.m_stage < -10.0) {
                    this.ResetSproingie();
                }
            }
        }
        else {
            //if (index !=0) //never expire the main Sproingie
				this.m_life -= nextStage;
        }
    }
    else if ((this.m_life += nextStage) >= 0.0) {
        // A sproingie is born.  Select the birthplace.

		if ((index > 10) && (groundlevel > 1)) {   // High-numbered Sproinge, Gadzooks ground...
            g_higher = -worldHeight + myrand(worldHeight*2);             // ...means large birth area.
            g_back = -worldWidth + myrand(worldWidth*2+1);
        }
        else if ((index > 5) && (groundlevel > 0)) { // Medium-number Sproingie, Lots of ground
            g_higher = -worldHeight + myrand(worldHeight*2);               // medium-sized birth area.
            g_back = -worldWidth/2 + myrand(worldWidth+1);
        }
        else if (index > 1) {   // Small ID numbered Sproingies born to small ground area.
            g_higher = -worldHeight + myrand(worldHeight*2);
            g_back = -2 + myrand(5);
        }
        else if (index === 1) {  // "Second" Sproingie stays near center.
            g_higher = -2 + myrand(3);
            g_back = -1 + myrand(3);
        }
        else {   // "Main" Sproingie stays in center.
            g_higher = -1;
            g_back = 0;
        }

       				
		
        this.m_X = (-g_higher - g_back);		
        this.m_Y = (g_higher * 2);
        this.m_Z = (g_back - g_higher);				
        this.m_life = (40 + myrand(200));
        this.m_stage = -10.0;
        this.m_weirdBits = 0;
        this.m_boxiness = 0.02;
        this.m_width = 1.0;

        if (weirdness > 0) {
            this.m_weirdBits |= SP_BIT_AIRDROP;

            var probability = 52 - (weirdness * 2);

            if (probability < 2) {
                probability = 2;
            }

            if ((probability < 4) || (myrand(Math.floor(probability / 8)) === 0)) {
                if (myrand(probability) === 0) {
                    this.m_weirdBits |= SP_BIT_STRIPES;
                }
                if (myrand(probability) === 0) {
                    this.m_weirdBits |= SP_BIT_FAT;
                }
                if (myrand(probability) === 0) {
                    this.m_boxiness = (Math.random() * 0.2);
                }
                if (myrand(probability) === 0) {
                    this.m_width = (Math.random() + 0.4);
                }
            }
        }

        this.m_R = (40 + myrand(200)) / 255.0;
        this.m_G = (40 + myrand(200)) / 255.0;
        this.m_B = (40 + myrand(200)) / 255.0;
		
	if ( this.m_index == 0 )
	{	this.m_speed = 4;
		this.m_R = 1;
		this.m_G = 1;
		this.m_B = 1;
	}
	else
	{	if (useDifferentSpeeds)
		{
            this.m_speed = (this.m_R * 2.0) + (1.0 - (40.0 / 255.0));
        }
        else {
            this.m_speed = 1.0;
        }

        // This makes pink-compatible Sproingies for a possible Valentine's Day easter egg.
        //		this.m_R = 1.0;
        //		this.m_G = (40 + myrand(200)) / 255.0;
        //		this.m_B = (40 + myrand(200)) / 255.0;
        // This makes black and white sproingies for gray stairs.
		/*		if (myrand(2)) {
        			this.m_R = this.m_G = this.m_B = 40.0 / 255.0;
        		}
        		else {
        			this.m_R = this.m_G = this.m_B = 240.0 / 255.0;
        		}
		
		*/
		//New properties to merge sproingies who collide
		this.m_altR = this.m_R;
		this.m_altG = this.m_G;
		this.m_altB = this.m_B;
		this.m_merge = false;
		
        if (this.CheckCollision(0.0)) {
            // If one is already being born, just wait.
            this.m_life = -1.0;
        }

		
    }
    
    if ( this.m_index == 0 )
    {	if ( this.m_jumping )
	{	if ( this.m_stage > 6 )
		{	this.m_jumping = false;
		
			if ( this.m_jumpUp )
			{	if ( this.m_flipJump )
					this.m_X -= 1;
				else
					this.m_Z -= 1;
				
				this.m_Y += 1;
			}
			else
			{	if ( this.m_flipJump )
					this.m_Z += 1;
				else
					this.m_X += 1;
				
				this.m_Y -= 1;
			}
		}
	}
	else
	{	if ( this.m_stage > 0 )
			this.m_stage = 0;
	}
    }
};

Sproingie.prototype.ParametricSproingie = function( sproingie, sprType, fstage, flipSproingieV, sproingieBuffers, sproingieMatrix)
 {
	if (fstage < 0.0) { fstage = 0.0; }
	if (fstage > 6.0) { fstage = 6.0; }

	var fMoveX = (fstage > 2.0) ? ((Math.cos((fstage-2.0)*Math.PI*0.25)*-0.5+0.5)*fstage/6.0):0.0;
	fMoveX += 0.5;
	
	var fMoveY = 0;
	var fMoveZ = -0.5;
	
	if ( fstage > 2.0 )
	{
		if ( fstage < 4.0 )
			fMoveY = ( 0.25 + 0.25 * Math.cos( (fstage-4.0)*Math.PI*0.5));
		else
			fMoveY = (0.5-0.1325*((fstage-4.0)*(fstage-4.0)));
	}
	
	var fRotateY = 0;
	var fRotateZ = (fstage>1)?(Math.cos((fstage-1)*Math.PI/5.0)*-90.0+90.0):0.0;
	var fBendHeight = (fstage < 4.0)?(Math.cos(fstage*Math.PI*0.25)*-0.35+0.65):1.0;
	var fBendAngle = (Math.cos(fstage*Math.PI/3.0)*-45.0+45.0)*(6.0-fstage)/3.0;
	var fBulge = ((fstage<2.0)?(Math.sin(fstage*Math.PI*0.5)*0.25):(Math.sin((fstage+2)*Math.PI*0.25)*0.1));
	var fStretch = ((fstage<2.0)?(Math.sin(fstage*Math.PI*0.5)*-0.25+1.0):(Math.sin((fstage+2.0)*Math.PI*0.25)*-0.2+1.0));
	

	if (this.m_weirdBits & SP_BIT_AIRDROP) {
		// Old age Sproingie squishes flat against stair.
		if ((this.m_stage < 0.0) && (this.m_life < 10.0))
		{
			fBulge = (this.m_stage / -4.0);
		}
	}

	// Fat mode
	if ((this.m_weirdBits & SP_BIT_FAT) && (fBulge < 0.4)) {
		fBulge = 0.4;
	}

	// Skinny
	//fBulge -= 0.2f;

	if ( sprType == TYPE_JUMP )
	{
		fBendAngle = (Math.cos(fstage*Math.PI/3.0)*-45.0+45.0)*(6.0-fstage)/3.0;
		fBendAngle *= 0.5;
		fRotateZ = 0;
		
		var jumpUp = ( sproingie.m_index == 0 && sproingie.m_jumping && sproingie.m_jumpUp );
		
		if ( jumpUp )
		{
			if ( fstage < 4 )
				fMoveY = ( fstage * 0.3 );
			else
				fMoveY = ( (4*0.3) - ( (fstage-4) * 0.1 ) );
				
			fMoveX = -fMoveX;
			fRotateY = 180;
		}
		else
		{
		if ( fstage > 2.0 )
		{
			if ( fstage < 4.0 )
				fMoveY = ( 0.25 + 0.15 * Math.cos( (fstage-4.0)*Math.PI*0.5));
			else
					fMoveY = (0.4-0.35*((fstage-4.0)*(fstage-4.0)));
		}
		else
			fMoveY = 0;
	}
	}
	else if ( sprType == TYPE_ROLL )
	{
		fBulge = 0;
		fStretch = 1;
		fBendAngle = 0;
		fRotateZ = 90;
		
		fMoveX = (fstage > 2.0) ? ((Math.cos((fstage-2.0)*Math.PI*0.25)*-0.5+0.5)*fstage/6.0):0.0;
		fMoveZ = -0.5;
		
		if ( fstage > 2.0 )
		{
			if ( fstage < 4.0 )
				fMoveY = 0.25;
			else
				fMoveY = (0.25-0.25*((fstage-4.0)*(fstage-4.0)));
		}
		else
			fMoveY = 0.25;
		
		if ( flipSproingieV )
			fRotateY = -90;
		else
			fRotateY = 90;

		if ( fstage >= 5 )
		{
			if ( flipSproingieV )
				fRotateY -= ( ( ( fstage - 5 ) / 1 ) * 90 );
			else
				fRotateY += ( ( ( fstage - 5 ) / 1 ) * 90 );
		}
	}
	
	var iU, iV;  // ints
	var cosProfile = new Array(S_RES+1), sinProfile = new Array(S_RES+1);
	var sideProfile = new Array(S_RES+1), radialProfile = new Array(S_RES+1), yProfile = new Array(S_RES+1);
	var u, v, x, y, z, bulge;

	fBendAngle *= (Math.PI / 180.0);
	var fBendRadius = fBendHeight / fBendAngle;
	var fSinBendAngle = Math.sin(fBendAngle);
	var fCosBendAngle = Math.cos(fBendAngle);

		// Add 0.5 to x and z for original sproingie.
	mat4.translate(sproingieMatrix, [fMoveX, fMoveY, fMoveZ]);
	if ( fRotateY != 0 )
	{
		mat4.translate(sproingieMatrix, [0.5, 0, 0]);
		mat4.rotate(sproingieMatrix, fRotateY * DegToRad, [0.0, 1.0, 0.0]);
		mat4.translate(sproingieMatrix, [-0.5, 0, 0]);
	}
	mat4.rotate(sproingieMatrix, fRotateZ * DegToRad, [0.0, 0.0, -1.0]);

	// Build Sproingie shape profiles.
	for (iU = 0; iU <= S_RES; ++iU) {
		v = u = iU / S_RES;

		sinProfile[iU] = Math.sin(M_TWOPI * u);
		cosProfile[iU] = Math.cos(M_TWOPI * u);

		bulge = (XtoY(cosProfile[iU],3.0)*-0.5+0.5) * fBulge;  // This is v-based.
		yProfile[iU] = (Math.atan(v*6.0-3.0)*0.395+0.485) * fStretch;
		sideProfile[iU] = Math.pow(Math.sin(Math.PI*v),0.5)*((v*v-v+1.0)*2.3-1.3+bulge)*0.5;
		radialProfile[iU] = (Math.cos(Math.PI*((8.0*u)+1.0))*this.m_boxiness*BOXINESS+1.0)*this.m_width;
	}

    var vertices = [];
	// Generate the vertex array, with singular top and bottom points.
	for (iV = 0; iV <= S_RES; ++iV) {
		for (iU = 0; iU < S_RES; ++iU) {
			if ((iU === 0) || ((iV > 0) && (iV < S_RES))) {
				x = z = sideProfile[iV]*radialProfile[iU];
				x *= sinProfile[iU];
				y = yProfile[iV];
				z *= cosProfile[iU];
				
				var oX = x, oY = y;

				if (fBendAngle > 0.0000001)
				{
					if (oY > fBendHeight)
					{
						x = ((oX - fBendRadius) * fCosBendAngle +
							((oY - fBendHeight) * fSinBendAngle) + fBendRadius);

						y = ((fBendRadius - oX) * fSinBendAngle  +
							((oY - fBendHeight) * fCosBendAngle));
					}
					else if (oY > 0.0)
					{
						x = ((oX - fBendRadius) * Math.cos(oY / fBendRadius) + fBendRadius);
						y = ((fBendRadius - oX) * Math.sin(oY / fBendRadius));
					}
				}

				vertices.push(x, y, z);
			}
		}
	}
	
	// If S_RES === 4, that means 4 per row:
	// single, 4, 4, 4, single

	var normals = [];

	// indexof(p(u, v)) === ((v-1) * S_RES) + u + 1
	
	// v1 === p(0, 1)           - p((S_RES / 2), 1)        // South - North
    // v2 === p((S_RES / 4), 1) - p(((S_RES * 3) / 4), 1)  // West - East
    var NorthIndex = 3 * (Math.floor(S_RES/2) + 1);
    var SouthIndex = 3;
	var v1 = [
		vertices[SouthIndex] - vertices[NorthIndex],
		vertices[SouthIndex+1] - vertices[NorthIndex+1],
		vertices[SouthIndex+2] - vertices[NorthIndex+2] ];
    
    var EastIndex = 3 * (Math.floor(S_RES*0.75) + 1);
    var WestIndex = 3 * (Math.floor(S_RES*0.25) + 1);
	var v2 = [
		vertices[WestIndex] - vertices[EastIndex],
		vertices[WestIndex+1] - vertices[EastIndex+1],
		vertices[WestIndex+2] - vertices[EastIndex+2] ];

	MakeNormal(v1, v2, normals);
    
	for (iV = 1; iV < S_RES; ++iV) {
		for (iU = 0; iU < S_RES; ++iU) {
			// v1 === p(u, v-2)   - p(u, v)      // South - North
			// v2 === p(u-1, v-1) - p(u+1, v-1)  // West - East
			
			NorthIndex = 3 * ((iV === (S_RES-1)) ? ((S_RES-1) * S_RES + 1) : (iV * S_RES + iU + 1));
			SouthIndex = 3 * ((iV < 2) ? 0 : ((iV - 2) * S_RES + iU + 1));
			v1 = [
				vertices[SouthIndex] - vertices[NorthIndex],
				vertices[SouthIndex+1] - vertices[NorthIndex+1],
				vertices[SouthIndex+2] - vertices[NorthIndex+2] ];
			
			EastIndex = 3 * ((iU === (S_RES - 1)) ? ((iV - 1) * S_RES + 1) : ((iV - 1) * S_RES + iU + 2));
			WestIndex = 3 * ((iU < 1) ? (iV * S_RES) : ((iV - 1) * S_RES + iU));
			v2 = [
				vertices[WestIndex] - vertices[EastIndex],
				vertices[WestIndex+1] - vertices[EastIndex+1],
				vertices[WestIndex+2] - vertices[EastIndex+2] ];

			MakeNormal(v1, v2, normals);
		}
	}
	
	// v1 === p((S_RES / 2), S_RES-1) - p(0, S_RES-1)                  // North - South
	// v2 === p((S_RES / 4), S_RES-1) - p(((S_RES * 3) / 4), S_RES-1)  // West - East
	
    SouthIndex = 3 * ((S_RES-2) * S_RES + 1);
    NorthIndex = SouthIndex + 3 * (Math.floor(S_RES/2) + 1);
	v1 = [
		vertices[NorthIndex] - vertices[SouthIndex],
		vertices[NorthIndex+1] - vertices[SouthIndex+1],
		vertices[NorthIndex+2] - vertices[SouthIndex+2] ];
    
    WestIndex = SouthIndex + 3 * (Math.floor(S_RES*0.25) + 1);
    EastIndex = SouthIndex + 3 * (Math.floor(S_RES*0.75) + 1);
	v2 = [
		vertices[WestIndex] - vertices[EastIndex],
		vertices[WestIndex+1] - vertices[EastIndex+1],
		vertices[WestIndex+2] - vertices[EastIndex+2] ];

	MakeNormal(v1, v2, normals);

	gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBuffers.VertexPosition);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
	sproingieBuffers.itemSize = 3;
	sproingieBuffers.numItems = vertices.length / sproingieBuffers.itemSize;

	gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBuffers.VertexNormal);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
};

Sproingie.prototype.RenderSproingie = function(sproingieBuffers, mvMatrix) {
    var sproingieMatrix = mat4.create(mvMatrix);
    var flipSproingieV = false;
    var fstage = 0;    
	
	if (this.m_stage < 0.0) {    // -10.0 to just below 0.0
	    if (!(this.m_weirdBits & SP_BIT_AIRDROP)) {
			mat4.translate(sproingieMatrix, [this.m_X,
				this.m_Y + (this.m_stage / 9.0),
				this.m_Z]);
		}
		else {
		    if (this.m_life < 10.0) {  // Sproingie dies of old age
			    var tall = Math.pow((this.m_stage + 10.0) / 10.0, 2.0);
			    var wide = ((this.m_stage + 10.0) / 10.0);

			    if ( this.m_type == TYPE_ROLL )
			    {
			    	wide = 1;
			    }

				mat4.translate(sproingieMatrix, [this.m_X + 0.5,
					this.m_Y + 0.01,
					this.m_Z - 0.5]);
				mat4.scale(sproingieMatrix, [wide, tall, wide]);
				mat4.translate(sproingieMatrix, [-0.5, -0.01, 0.5]);
								
			}
			else {    // Sproingie being born
				var drop = 10.0 - ((this.m_stage + 10.0) *
					(this.m_stage + 10.0) / 10.0);

				mat4.translate(sproingieMatrix, [this.m_X + 0.5,
					this.m_Y + drop,
					this.m_Z - 0.5]);
				mat4.scale(sproingieMatrix, [
				    (this.m_stage + 10.0) / 10.0,
					(this.m_stage + 10.0) / 10.0,
					(this.m_stage + 10.0) / 10.0]);
				mat4.translate(sproingieMatrix, [-0.5, 0.0, 0.5]);
			}
		}
		fstage = 0.0;
	}
	else if ( this.m_index == 0 )
	{
		if ( this.m_jumping && this.m_jumpUp != this.m_flipJump )
		{
			mat4.translate(sproingieMatrix, [this.m_X, this.m_Y, this.m_Z-1]);
			mat4.rotate(sproingieMatrix, -90.0 * DegToRad, [0.0, 1.0, 0.0]);
			flipSproingieV = true;
		}
		else
		{
			mat4.translate(sproingieMatrix, [this.m_X, this.m_Y, this.m_Z]);
		}

		if ( this.m_jumping )
			fstage = this.m_stage;
		else
			fstage = 0;
	}
	else if (this.m_stage >= 6.0) {
		mat4.translate(sproingieMatrix, [this.m_X + 1, this.m_Y - 1, this.m_Z - 1]);
		mat4.rotate(sproingieMatrix, -90.0 * DegToRad, [0.0, 1.0, 0.0]);
		flipSproingieV = true;
		fstage = (this.m_stage - 6.0);
	}
	else {
		mat4.translate(sproingieMatrix, [this.m_X, this.m_Y, this.m_Z]);
		fstage = this.m_stage;
	}
	
	this.ParametricSproingie( this, this.m_type, fstage, flipSproingieV, sproingieBuffers, sproingieMatrix);
	
    gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBuffers.VertexPosition);
    gl.vertexAttribPointer(sproingieShaderProgram.vertexPositionAttribute,
        sproingieBuffers.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBuffers.VertexNormal);
    gl.vertexAttribPointer(sproingieShaderProgram.vertexNormalAttribute,
        sproingieBuffers.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBuffers.UVCoords);
    gl.vertexAttribPointer(sproingieShaderProgram.aUVCoords,
        sproingieBuffers.uvItemSize, gl.FLOAT, false, 0, 0);

    setMatrixUniforms(sproingieShaderProgram, sproingieMatrix);
    if ((this.m_weirdBits & SP_BIT_STRIPES) === 0) {
        setMaterial(sproingieShaderProgram, this.m_R, this.m_G, this.m_B, SPECULAR,
            this.m_R, this.m_G, this.m_B);
    } else if (this.m_merge) { // Combine the alt color and main color if there was a Sproingie merge
        setMaterial(sproingieShaderProgram, this.m_R, this.m_G, this.m_B, SPECULAR,
            this.m_altR, this.m_altG, this.m_altB);
    } else if (!flipSproingieV) {
        setMaterial(sproingieShaderProgram, this.m_R, this.m_G, this.m_B, SPECULAR,
            1.0 - this.m_R, 1.0 - this.m_G, 1.0 - this.m_B);
    } 	
	else {
		setMaterial(sproingieShaderProgram, 1.0 - this.m_R, 1.0 - this.m_G, 1.0 - this.m_B, 0.5,
            this.m_R, this.m_G, this.m_B);
	}
		
	//this.m_altR, this.m_altG, this.m_altB
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sproingieBuffers.VertexIndex);
    gl.drawElements(gl.TRIANGLE_STRIP, sproingieBuffers.numIndices, gl.UNSIGNED_SHORT, 0);
};

Sproingie.prototype.RenderSproingieBoom = function(sproingieBuffers, mvMatrix, dist) {
    var sproingieBoomMatrix = mat4.create(mvMatrix);

    mat4.translate(sproingieBoomMatrix, [this.m_X + 0.5, this.m_Y + 0.5, this.m_Z - 0.5]);
    var scale = ((this.m_stage - BOOM_STAGE) * 2.0);
    mat4.scale(sproingieBoomMatrix, [scale, scale, scale]);
    
    var pointsize = ((BOOM_STAGE + 8.0) - this.m_stage) - (dist / 64.0);
    if (pointsize < 1.0) {
        pointsize = 1.0;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBoomBuffers.VertexPosition);
    gl.vertexAttribPointer(sproingieBoomShaderProgram.vertexPositionAttribute,
        sproingieBoomBuffers.itemSize, gl.FLOAT, false, 0, 0);

    setBoomUniforms(sproingieBoomShaderProgram, sproingieBoomMatrix,
        this.m_R, this.m_G, this.m_B, pointsize);
        
    gl.drawArrays(gl.POINTS, 0, sproingieBoomBuffers.numItems);
};

function SproingieTriangleStrip(sproingieBuffers) {
    // Triangle strip
    var indices = [];
    var SouthIndex = (S_RES - 2) * S_RES + 1;
    var NorthIndex = (S_RES - 1) * S_RES + 1;
    
    for (iU = 0; iU < S_RES; ++iU) {
        indices.push(0, iU + 1);
    }
    indices.push(0, 1);
    for (iV = 2; iV < S_RES; ++iV) {
        for (iU = 0; iU < S_RES; ++iU) {
            indices.push((iV - 2) * S_RES + iU + 1, (iV - 1) * S_RES + iU + 1);
        }
        indices.push((iV - 2) * S_RES + 1, (iV - 1) * S_RES + 1);
    }
    for (iU = 0; iU < S_RES; ++iU) {
        indices.push(iU + SouthIndex, NorthIndex);
    }
    indices.push(SouthIndex);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sproingieBuffers.VertexIndex);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    sproingieBuffers.numIndices = indices.length;

    var UVs = [];
    for (iV = 0; iV <= S_RES; ++iV) {
        for (iU = 0; iU < S_RES; ++iU) {
            UVs.push(iU, iV);
            if ((iV === 0) || (iV === S_RES)) {
                break;
            }
        }
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBuffers.UVCoords);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(UVs), gl.STATIC_DRAW);
    sproingieBuffers.uvItemSize = 2;
    sproingieBuffers.uvNumItems = UVs.length / sproingieBuffers.uvItemSize;
}

function SetMaxSproingies(max) {
    var len = sproingieList.length;
    
    if (len > max) {
        sproingieList = sproingieList.slice(0, max);
    }
    else {
        while (len < max) {
            sproingieList.push(new Sproingie(len, max));
            ++len;
        }
    }
}

  //
  // Compute the groundBuffers
  //
  function computeGround(halfWidth, halfHeight, groundBuffers) {
      var fullWidth = (halfWidth * 2) + 1;
      var fullHeight = (halfHeight * 2);

      var startX = -halfHeight - halfWidth;
      var startY = fullHeight;
      var startZ = halfWidth - halfHeight;

      var vertices = [];
      var normals = [];
      var indices = [];

      var one_normal_group = [
      // Upper top
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
      // Lower top
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
          0, 1, 0,
      // Upper left
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
      // Lower left
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
      // Upper right
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
      // Lower right
          1, 0, 0,
          1, 0, 0,
          1, 0, 0,
          1, 0, 0
      ];

      var one_index_group = [
      // Upper top
          0, 1, 2,
          0, 2, 3,
      // Lower top
          4, 5, 6,
          4, 6, 7,
      // Upper left
          8, 9, 10,
          8, 10, 11,
      // Lower left
          12, 13, 14,
          12, 14, 15,
      // Upper right
          16, 17, 18,
          16, 18, 19,
      // Lower right
          20, 21, 22,
          20, 22, 23
      ];

      var addTwentyFour = function(element, index, array) {
          array[index] += 24;
          return true;
      };

	  
      var h;
      for (h = 0; h < fullHeight; ++h) {
          var x = startX + h;
          var y = startY - (h * 2);
          var z = startZ + h;

		  
		  
          var w;
          for (w = 0; w < fullWidth; ++w) {
              normals = normals.concat(one_normal_group);
              indices = indices.concat(one_index_group);
              one_index_group.every(addTwentyFour);          			 
			   vertices = vertices.concat([
                 // Upper top
			        x,     y, z,
			        x,     y, z - 1,
			        x + 1, y, z - 1,
			        x + 1, y, z,
			    // Lower top
			        x + 1, y - 1, z,
			        x + 1, y - 1, z - 1,
			        x + 2, y - 1, z - 1,
			        x + 2, y - 1, z,
                // Upper left
			        x,     y    , z,
			        x + 1, y    , z,
			        x + 1, y - 1, z,
			        x,     y - 1, z,
                // Lower left
			        x + 1, y - 1, z,
			        x + 2, y - 1, z,
			        x + 2, y - 2, z,
			        x + 1, y - 2, z,
                // Upper right
			        x + 1, y    , z,
			        x + 1, y    , z - 1,
			        x + 1, y - 1, z - 1,
			        x + 1, y - 1, z,
                // Lower right
			        x + 2, y - 1, z,
			        x + 2, y - 1, z - 1,
			        x + 2, y - 2, z - 1,
			        x + 2, y - 2, z
              ]);              
              ++x;
              --z;
          }
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, groundBuffers.VertexPosition);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      groundBuffers.itemSize = 3;
      groundBuffers.numItems = vertices.length / groundBuffers.itemSize;

      gl.bindBuffer(gl.ARRAY_BUFFER, groundBuffers.VertexNormal);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, groundBuffers.VertexIndex);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      groundBuffers.numIndices = indices.length;
  }

  function initBuffers() {
      groundBuffers = {};
      groundBuffers.VertexPosition = gl.createBuffer();
      groundBuffers.VertexNormal = gl.createBuffer();
      groundBuffers.VertexIndex = gl.createBuffer();
      
      computeGround(worldWidth, worldHeight, groundBuffers);

      sproingieBuffers = {};
      sproingieBuffers.VertexPosition = gl.createBuffer();
      sproingieBuffers.VertexNormal = gl.createBuffer();
      sproingieBuffers.VertexIndex = gl.createBuffer();
      sproingieBuffers.UVCoords = gl.createBuffer();
      SproingieTriangleStrip(sproingieBuffers);

      sproingieBoomBuffers = {};
      sproingieBoomBuffers.VertexPosition = gl.createBuffer();

      gl.bindBuffer(gl.ARRAY_BUFFER, sproingieBoomBuffers.VertexPosition);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(s1_b_PNTS), gl.STATIC_DRAW);
      sproingieBoomBuffers.itemSize = 3;
      sproingieBoomBuffers.numItems = s1_b_PNTS.length / sproingieBoomBuffers.itemSize;
  }


  function drawScene() {
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	
    var pMatrix = mat4.create();
	var fov = 88.0;

	if ((gl.viewportWidth > gl.viewportHeight) && (gl.viewportHeight > 0))
	{
	    fov *= (gl.viewportHeight / gl.viewportWidth);
	}
	mat4.perspective(fov, gl.viewportWidth / gl.viewportHeight, 0.1, 2000.0, pMatrix);

	var mvMatrix = mat4.create();
	mat4.identity(mvMatrix);
    eye = cameras[selectedCam];
    eye[2] = 100 * (1 - zoom[selectedCam]) + 2;
    mvMatrix = mat4.lookAt(eye, lookAt, up);
	
	mat4.rotate(mvMatrix, rotCameraX[selectedCam] * DegToRad, [1.0, 0.0, 0.0]);
	mat4.rotate(mvMatrix, rotCameraY[selectedCam] * DegToRad, [0.0, 1.0, 0.0]);

	var worldMatrix = mat4.create(mvMatrix);

    var groundPos = [ground * (-1.0 / 12.0) - 0.75,
		ground * (2.0 / 12.0) - 0.5, // Multiply the ground Y by the height to achieve smooth scaling -MB
		ground * (-1.0 / 12.0) + 0.75];
		
    mat4.translate(mvMatrix, groundPos);

    //
    // Render the ground
    //
    gl.useProgram(groundShaderProgram);

    gl.bindBuffer(gl.ARRAY_BUFFER, groundBuffers.VertexPosition);
    gl.vertexAttribPointer(groundShaderProgram.vertexPositionAttribute,
        groundBuffers.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, groundBuffers.VertexNormal);
    gl.vertexAttribPointer(groundShaderProgram.vertexNormalAttribute,
        groundBuffers.itemSize, gl.FLOAT, false, 0, 0);

    setLights(groundShaderProgram, worldMatrix);
    setProjectionUniforms(groundShaderProgram, pMatrix, groundPos);
    setMatrixUniforms(groundShaderProgram, mvMatrix);
    setMaterial(groundShaderProgram,
        groundRGB[0],groundRGB[1],groundRGB[2], 0.5,  // Side RGB, Side specularity
        0.392157, 0.784314, 0.941176);      // Top RGB
    
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, groundBuffers.VertexIndex);
    gl.drawElements(gl.TRIANGLES, groundBuffers.numIndices, gl.UNSIGNED_SHORT, 0);

    //
    // Render the Sproingies!
    //
    gl.useProgram(sproingieShaderProgram);

    setLights(sproingieShaderProgram, worldMatrix);
    setProjectionUniforms(sproingieShaderProgram, pMatrix, groundPos);

    var numSproingies = sproingieList.length;
    var t;

    for (t = 0; t < numSproingies; ++t) {
        if ((sproingieList[t].m_life > 0.0) &&
            (sproingieList[t].m_stage < (BOOM_STAGE - 0.001))) {
            sproingieList[t].RenderSproingie(sproingieBuffers, mvMatrix);
        }
    }
    
    //
    // Render the explosions
    //
    gl.useProgram(sproingieBoomShaderProgram);
    setProjectionUniforms(sproingieBoomShaderProgram, pMatrix, groundPos);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, dotTexture);
    gl.uniform1i(sproingieBoomShaderProgram.uDotSampler, 0);
    
    gl.enable(gl.BLEND);
    for (t = 0; t < numSproingies; ++t) {
        if ((sproingieList[t].m_life > 0.000001) &&
            (sproingieList[t].m_stage >= (BOOM_STAGE - 0.001))) {
            sproingieList[t].RenderSproingieBoom(sproingieBuffers, mvMatrix, dist);
        }
    }
    gl.disable(gl.BLEND);
}

  function nextSproingie(timePassed) {
      var nextStage = timePassed * howfast * 0.333333333;
      var numSproingies = sproingieList.length;
      var t;

     // if ((ground += nextStage) >= 12.0) {
      //    ground -= 12.0;
        //  for (t = 0; t < numSproingies; ++t) {
        //      sproingieList[t].m_X -= 1;
        //      sproingieList[t].m_Y += 2;
        //      sproingieList[t].m_Z -= 1;
        //  }
     // }
				
      for (t = 0; t < numSproingies; ++t) {
          sproingieList[t].AdvanceSproingie(nextStage);
      }

      if (target_wait < 0.0) {   /* track to current target */
          var howFar = Math.pow(CAMERA_SLIDE_RATE, (timePassed * 1000.0));
          if (howFar > 0.9999) {
              howFar = 0.9999;
          }

          //rotx = target_rx + (howFar * (rotx - target_rx));
          //roty = target_ry + (howFar * (roty - target_ry));
          dist = target_dist + (howFar * (dist - target_dist));

          if ((Math.abs(target_rx - rotx) < 0.01) &&
			  (Math.abs(target_ry - roty) < 0.01) &&
			  (Math.abs(target_dist - dist) < 0.01)) {
              target_wait = max_target_wait;
              if (target_dist <= 32) {
                  target_wait *= 0.25;
              }
          }
      }
      else if ((target_wait -= (timePassed * 10.0)) < 0.0) {   /* make up new target */
          var old_dist = target_dist;

          target_wait = -1.0;
          target_rx = myrand(100) - 35;
          target_ry = -myrand(90);
          target_dist = 32 << myrand(2);  /* could be 32, 64, or 128, (previously or 256) */

          if (target_dist >= old_dist) { /* no duplicate distances */
              target_dist *= 2.0;
          }
      }
      /* Otherwise just hang loose for a while here */
  }

  function animate() {
    var timeNow = new Date().getTime();
    if (lastTime !== 0) {
        keyPos = [0.0, 0.0, -4.0];
      lightRot += lightRotSpeed;
    
        var timePassed = (timeNow - lastTime) * 0.001;
        fpsTime += timePassed;
        fpsFrames++;

        if (fpsFrames <= 0) {
            fpsTime = timePassed = 0;
        } else if (fpsTime > 2) {
            var fps = fpsFrames / fpsTime;
            $(".showFPS").html(fps.toFixed(2) + " fps");
            fpsFrames = fpsTime = 0;
        }

		
        if (timePassed > 1.0e-5) {
		
            if (looking < -0.00001) {
                lookAway += looking * timePassed;

                if (lookAway < 0.0) {
                    lookAway = 0.0;
                    looking = 0.0;
                }
            }

            if (!isPaused) {
                nextSproingie(timePassed);
            }
        }

        if (toolbarVisible) {
            toolbarLife -= timePassed;
            if (toolbarLife < 0) {
                toolbarVisible = false;
                $("#toolbar").hide("fade", {}, TOOLBAR_FADE_SPEED);
                //$("body").css('cursor', 'none');
            }
        }
		
		//Fade the ground colors
		changeGroundColors();
		
    }
	
	
    lastTime = timeNow;
  }

  function changeGroundColors()
  {
		if (parseInt(nextGroundRGB[0] * 255) < parseInt(groundRGB[0] * 255))
			groundRGB[0] -= (5+colorTime)/1000;
		else if (parseInt(nextGroundRGB[0] * 255) > parseInt(groundRGB[0] * 255))
			groundRGB[0] += (5+colorTime)/1000;
			
		if (parseInt(nextGroundRGB[1] * 255) < parseInt(groundRGB[1] * 255))
			groundRGB[1] -= (5+colorTime)/1000;
		else if (parseInt(nextGroundRGB[1] * 255) > parseInt(groundRGB[1] * 255))
			groundRGB[1] += (5+colorTime)/1000;
		
		if (parseInt(nextGroundRGB[2] * 255) < parseInt(groundRGB[2] * 255))
			groundRGB[2] -= (5+colorTime)/1000;
		else if (parseInt(nextGroundRGB[2] * 255) > parseInt(groundRGB[2] * 255))
			groundRGB[2] += (5+colorTime)/1000;
  }
  
  function changeColorTimer()
  {
	if (colorTime)	
		nextGroundRGB = [ Math.random(), Math.random(), Math.random() ];	
	
	setTimeout("changeColorTimer()",colorTime*1000);	
  }

  function tick() {
    requestAnimFrame(tick);
    drawScene();
    animate();
  }

  function handleMouseDown(event) {
      mouseDown = event.button;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
  }

  function handleMouseUp(event) {
      mouseDown = -1;
  }

  function handleMouseMove(event) {
      //document.getElementById("info").innerHTML = "Button " + event.button;
      if (mouseDown < 0) {
          toolbarLife = MAX_TOOLBAR_LIFE;
          if (!toolbarVisible) {
              toolbarVisible = true;
              $("#toolbar").show("fade", {}, TOOLBAR_FADE_SPEED);
              //$("body").css('cursor', 'auto');
          }
          return;
      }

      var dx = event.clientX - lastMouseX;
      var dy = event.clientY - lastMouseY;

      lastMouseX = event.clientX;
      lastMouseY = event.clientY;

      if (mouseDown === 0) {
          target_wait = max_target_wait * 2.0;
          rotCameraX[selectedCam] += dy * 0.5;
          rotCameraY[selectedCam] += dx * 0.5;

          if (rotCameraX[selectedCam] < -35.0) { rotCameraX[selectedCam] = -35.0; }
          if (rotCameraX[selectedCam] > 65.0) { rotCameraX[selectedCam] = 65.0; }

          if (rotCameraY[selectedCam] < -90.0) { rotCameraY[selectedCam] = -90.0; }
          if (rotCameraY[selectedCam] > 0.0) { rotCameraY[selectedCam] = 0.0; }
      }
      else {
          target_wait = max_target_wait * 2.0;
          dist += (dist * -0.01 * dy);

		  if ((zoom[selectedCam] <= 1 || dy > 0) && (zoom[selectedCam] >= 0 || dy < 0)){
			  ///var z = zoom + (zoom * 0.01 * dy); 
			  var z = zoom[selectedCam] + (0.005 * dy);
			  if (z <= 1 && z >= 0)
			  zoom[selectedCam] = z;
      		$("#zoomLevel").html(zoom[selectedCam].toFixed(2) * 100);
      		$("#zoomLevelSlider").slider({value: zoom[selectedCam]});
		  }

		  /* var r = rotCameraY + dx;
		  if(r < 90 && r > -90)
		  rotCameraY = r; */

          if (dist < 32.0) { dist = 32.0; }
          if (dist > 256.0) { dist = 256.0; }
      }
  }

  function handleDblClick(event) {
      zoomIn();
  }
  
  function zoomIn(){
      if (zoom[selectedCam] < 0.99){
      zoom[selectedCam] += (1 - zoom[selectedCam]) * .2;
      $("#zoomLevel").html(zoom[selectedCam].toFixed(2) * 100);
      $("#zoomLevelSlider").slider({value: zoom[selectedCam]});
      }
    }
    
  function handleKeys(event) {
	       // alert('Key code: ' + event.keyCode);
        k = event.keyCode;
        switch(k)
        {
            case 49: //1
				selectedCam = 0;
				break;
            case 50: //2
				selectedCam = 1;
				break;
            case 51: //3
				selectedCam = 2;
				break;
            case 52: //4
				selectedCam = 3;
				break;			
			
            default:
				break;
				break;
        }
        //alert('selected camera =' + selectedCam);
      }
    

  function webGLStart() {
    var canvas = document.getElementById(glCanvasName);
    initGL(canvas);
    if (!gl) { return; }
    window.onresize = resizeGL;
    
    groundShaderProgram = gl.createProgram();
    initShaders(groundShaderProgram, "shader-fs-ground", "shader-vs-ground");
    sproingieShaderProgram = gl.createProgram();
    initShaders(sproingieShaderProgram, "shader-fs-sproingie", "shader-vs-sproingie");
    sproingieBoomShaderProgram = gl.createProgram();
    initBoomShaders(sproingieBoomShaderProgram, "shader-fs-boom", "shader-vs-boom");

    initBuffers();
    initTextures();

    SetMaxSproingies(DEFAULT_NUM_SPROINGIES);

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clearDepth(1.0);

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    // The original Sproingies used clockwise surfaces,
    // for reasons lost to the sands of time...
    // (Probably because they were modeled in Lightwave 3D back in the 90's...)
    gl.frontFace(gl.CW);
    gl.enable(gl.CULL_FACE);

    canvas.onmousedown = handleMouseDown;
    document.onmouseup = handleMouseUp;
    document.onmousemove = handleMouseMove;
    document.ondblclick = handleDblClick;
    document.onkeypress = handleKeys;
	document.onkeydown = handleKeyDown;
	
	changeColorTimer();
	
    tick();
  }

  function handleKeyDown(evt)
  {
  	if ( sproingieList[0].m_jumping )
		return;
	
	switch (evt.keyCode)
	{
		default:
			return;
	
		case 27: // escape
			sproingieList[0].m_life = 10;
			sproingieList[0].m_stage = BOOM_STAGE;
			return;
			
			//up left
			case 37: // left arrow
			case 69: // e                
		case 100: // numpad left
		case 103: // numpad 7
			sproingieList[0].m_jumpUp = true;
			sproingieList[0].m_flipJump = true;
			sproingieList[0].m_jumping = true;

                break;   
			//up right
		case 38: // up arrow
			case 82: // r
		case 104: // numpad up
		case 105: // numpad 9
			sproingieList[0].m_jumpUp = true;
			sproingieList[0].m_flipJump = false;
			sproingieList[0].m_jumping = true;
			break;   
			
		// down right
		case 39: // right arrow
		case 70: // f
		case 102: // numpad right
		case 99: // numpad 3
			sproingieList[0].m_jumpUp = false;
			sproingieList[0].m_flipJump = false;
			sproingieList[0].m_jumping = true;
                break;   
			//down left
		case 40: // down arrow
			case 68: // d
		case 98: // numpad down
		case 97: // numpad 1
			sproingieList[0].m_jumpUp = false;
			sproingieList[0].m_flipJump = true;
			sproingieList[0].m_jumping = true;
                break;    
	}
  }
  
  function insertInspector() {
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src = "js/webgl-inspector/embed.js";
      document.head.appendChild(script);
  }

  function startup() {
      if (document.URL.indexOf("inspect=1") > 1) {
          window.afterInspectorLoad = webGLStart;
          insertInspector();
      }
      else {
          webGLStart();
      }
  }

  // Slider sets code
  function ReadMaxSproingies(val) {
      val = 101 - val;
      var x = 2.0 - (val / 50.0);
      var y = Math.floor((Math.exp(x * 1.2) * 10.0 - 7.0) + 0.5);

      SetMaxSproingies(y);
      $("#howManyNum").html(y);
      return y;
  }

  // Code sets slider
  function PutMaxSproingies(num) {
      //var num = sproingieList.length;
      $("#howManyNum").html(num);
      var x = Math.log((num + 7.0) / 10.0) / 1.2;
      var y = Math.floor(((2.0 - x) * 50.0) + 0.5);
      y = 101 - y;

      if (y < 1) { y = 1; }
      if (y > 100) { y = 100; }

      return y;
  }

  // Slider sets code
  function ReadHowFast(val) {
      val = 101 - val;
      var x = 2.0 - (val / 50.0);
      var y = Math.floor((Math.exp(x * 1.2) * 10.0 - 7.0) + 0.5);

      howfast = y;
      $("#howFastNum").html(y);
      return y;

  }
  // Code sets slider
  function PutHowFast() {
      $("#howFastNum").html(howfast);
      var x = Math.log((howfast + 7.0) / 10.0) / 1.2;
      var y = Math.floor(((2.0 - x) * 50.0) + 0.5);
      y = 101 - y;

      if (y < 1) { y = 1; }
      if (y > 100) { y = 100; }

      return y;
  }

  $(function() {

      // Add the ".checked()" function to jQuery
      $.fn.checked = function(value) {
          // From http://stackoverflow.com/questions/426258/how-do-i-check-a-checkbox-with-jquery-or-javascript
          //  and http://jsfiddle.net/xixionia/WnbNC/
          if (value === true || value === false) {
              // Set the value of the checkbox
              $(this).each(function() { this.checked = value; });
          } else if (value === undefined || value === 'toggle') {
              // Toggle the checkbox
              $(this).each(function() { this.checked = !this.checked; });
          }
          return $(this);
      };

      var inspectorVisible = (document.URL.indexOf("inspect=1") > 1);

      $("#settingsDialog").dialog({
          autoOpen: false,
          show: "fade",
          hide: "fade",
          width: 325,
          minWidth: 325,
          resizable: false,
          buttons: { "Ok": function() { $(this).dialog("close"); } }
      });
	  $("#sproingieShineNum").html(SPECULAR);
	  $("#sproingieShineSlider").slider({
          min: 0.5,
          max: 50,
          value: colorTime,
		  step: 0.5,
          animate: true,
          orientation: "vertical",
          slide: function(event, ui) { SPECULAR = ui.value; $("#sproingieShineNum").html(SPECULAR); return true; }
      });
	  
	  $("#rotateColorNum").html(colorTime);
	  $("#rotateColorSlider").slider({
          min: 0,
          max: 10,
          value: colorTime,
          animate: true,
          orientation: "vertical",
          slide: function(event, ui) { colorTime = ui.value; $("#rotateColorNum").html(colorTime + " Second"); return true; }
      });	
	  $("#worldWidthNum").html(worldWidth);
	  $("#worldWidthSlider").slider({
          min: 2,
          max: 16,
		  step: 2,
          value: worldWidth,
          animate: true,
          orientation: "vertical",
          slide: function(event, ui) { worldWidth = ui.value; $("#worldWidthNum").html(worldWidth); computeGround(worldWidth, 16, groundBuffers); return true; }
      });
      $("#howManySlider").slider({
          min: 1,
          max: 100,
          value: PutMaxSproingies(DEFAULT_NUM_SPROINGIES),
          animate: true,
          orientation: "vertical",
          slide: function(event, ui) { ReadMaxSproingies(ui.value); return true; }
      });
      $("#howFastSlider").slider({
          min: 1,
          max: 100,
          value: PutHowFast(),
          animate: true,
          orientation: "vertical",
          slide: function(event, ui) { ReadHowFast(ui.value); return true; }
      });
      $("#howFunkyNum").html(weirdness);
      $("#howFunkySlider").slider({
          min: 0,
          max: 25,
          value: weirdness,
          animate: true,
          orientation: "vertical",
          slide: function(event, ui) { weirdness = ui.value; $("#howFunkyNum").html(weirdness); return true; }
      });
	  $("#shapeNum").html(BOXINESS);
      $("#shapeSlider").slider({
          min: 0,
          max: 2,
          value: BOXINESS,
          animate: true,
          orientation: "vertical",
          slide: function(event, ui) { BOXINESS = ui.value*10; $("#shapeNum").html(BOXINESS/10); return true; }
      });
      $("#zoomLevel").html(zoom[selectedCam].toFixed(2) * 100);
      $("#zoomLevelSlider").slider({
          min: 0,
          max: 1,
          step: 0.01,
          value: zoom[selectedCam],
          animate: true,
          orientation: "vertical",
          slide: function(event, ui) { zoom[selectedCam] = ui.value; $("#zoomLevel").html(zoom[selectedCam].toFixed(2) * 100); return true; }
      });

      $("#infoDialog").dialog({
          autoOpen: false,
          show: "fade",
          hide: "fade",
          width: 730,
          zIndex: 2000,
          buttons: { "Ok": function() { $(this).dialog("close"); } }
      });

      $("#play").button({
          text: true,
          icons: {
              primary: "ui-icon-pause"
          }
      }).click(function() {
          var options;
          if ($(this).text() === "play") {
              isPaused = false;
              options = {
                  label: "pause",
                  icons: {
                      primary: "ui-icon-pause"
                  }
              };
          } else {
              isPaused = true;
              options = {
                  label: "play",
                  icons: {
                      primary: "ui-icon-play"
                  }
              };
          }
          $(this).button("option", options);
      });
      $("#showInfo").button({
          text: true,
          icons: {
              primary: "ui-icon-info"
          }
      }).click(function() {
          if ($("#infoDialog").is(":visible")) {
              $("#infoDialog").dialog("close");
          } else {
              $("#infoDialog").dialog("open");
          }
      });
      $("#showSettings").button({
          text: true,
          icons: {
              primary: "ui-icon-wrench"
          }
      }).click(function() {
          if ($("#settingsDialog").is(":visible")) {
              $("#settingsDialog").dialog("close");
          } else {
              $("#settingsDialog").dialog("open");
          }
      });
      $("#showInspector").checked(inspectorVisible).button({
          text: true,
          icons: {
              primary: "ui-icon-script"
          }
      }).click(function() {
          document.location = "Sproingies.html" + (inspectorVisible ? "" : "?inspect=1");
      });

      // Move the version text to the bottom of the dialog.
      $(".ui-dialog:has(#infoDialog) .ui-dialog-buttonpane").prepend('<div class="version2">' + $("div.version").html() + "<\/div>");
      $(".version").remove();
      
      // Make an FPS display
      $(".ui-dialog:has(#settingsDialog) .ui-dialog-buttonpane").prepend('<div class="showFPS"><\/div>');
  });
  
</script>

<!-- This section is Google tracking stuff, nothing WebGL related here...  -->
<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-21849136-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>
<!-- End of Google tracking stuff. -->

</head>


<body onload="startup();">

  <!-- The parent node of the canvas can get an error written into it by webgl-utils.js. -->
  <div id="canvasContainer">
    <canvas id="glCanvas" width="800" height="600"></canvas>
  </div>

  <div id="loadingWebGL">Loading...</div>
  <div id="missingWebGL"><span class="redBox">Looks like your browser doesn't support WebGL.</span>
      <a href="http://learningwebgl.com/blog/?p=11" target="_blank">Quick fix: get a browser that supports WebGL</a>
  </div>

    <div id="toolbar">
        <button id="play">pause</button>
        <button id="showInfo">info</button>
        <input type="checkbox" id="showInspector" /><label for="showInspector">inspector</label>
        <button id="showSettings">settings</button>
    </div>
    
    <div id="settingsDialog" title="Sproingies settings">
        <div id="settingsSliders">
            <div class="sliderBox ui-widget ui-corner-all">
                <p>How<br />many</p>
                <span id="howManySlider"></span>
                <p id="howManyNum">&nbsp;</p>
            </div>
            <div class="sliderBox ui-widget ui-corner-all">
                <p>How<br />fast</p>
                <span id="howFastSlider"></span>
                <p id="howFastNum">&nbsp;</p>
            </div>
            <div class="sliderBox ui-widget ui-corner-all">
                <p>How<br />funky</p>
                <span id="howFunkySlider"></span>
                <p id="howFunkyNum">&nbsp;</p>
            </div>
			<div class="sliderBox ui-widget ui-corner-all">
                <p>Rotate<br />Color</p>
                <span id="rotateColorSlider"></span>
                <p id="rotateColorNum">&nbsp;</p>
            </div>			
			<div class="sliderBox ui-widget ui-corner-all">
                <p>Sproingie<br />Boxiness</p>
                <span id="shapeSlider"></span>
                <p id="shapeNum">&nbsp;</p>
            </div>
			<div class="sliderBox ui-widget ui-corner-all">
                <p>World<br />Width</p>
                <span id="worldWidthSlider"></span>
                <p id="worldWidthNum">&nbsp;</p>
            </div>
			<div class="sliderBox ui-widget ui-corner-all">
                <p>Sproingie<br />Shineness</p>
                <span id="sproingieShineSlider"></span>
                <p id="sproingieShineNum">&nbsp;</p>
            </div>
			<div class="sliderBox ui-widget ui-corner-all">
                <p>Zoom<br />Level</p>
                <span id="zoomLevelSlider"></span>
                <p id="zoomLevel">&nbsp;</p>
            </div>
        </div>
    </div>
    
    <div id="infoDialog" title="About the Sproingies">
	    <p><a href="https://bitbucket.org/emackey/sproingies/wiki" target="_blank"><img
              class="infoIcon" src="images/icon_Sproingie.jpg" alt="Sproingie" width="72" height="72" /></a>
	       After years of seclusion, the youngest generation of Sproingies make an appearence
           on a WebGL canvas.  Code by
           <a href="http://twitter.com/emackey" target="_blank">@emackey</a> based on
           <a href="http://learningwebgl.com/" target="_blank">Learning WebGL</a> and
           other sources.  Original Sproingie design by Al Mackey.
        </p>
        <p>Sproingies have a long journey behind them, beginning in
           <a href="http://avl.enemy.org/Gallery/sproingy/" target="_blank">1997</a>, and they
           have a long journey ahead of them. Luckily they are bouncy and full of energy.
           They are also nontoxic, safe for pets and small children.
        </p>
        <p>Read more about them on the
           <a href="https://bitbucket.org/emackey/sproingies/wiki" target="_blank">Sproingie Wiki</a>,
           or download their source code from the
           <a href="https://bitbucket.org/emackey/sproingies/src/tip/webgl/" target="_blank">Sproingie Repository</a>.
        </p>
        <div class="version">Version 1.0a, last modified 5 June 2011.</div>
    </div>

</body></html>